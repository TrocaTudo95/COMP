options
{
  LOOKAHEAD=1;
  MULTI=true;
}

PARSER_BEGIN(grammar)
// c√≥digo Java que invoca o parser
import java.io.*;
public class grammar {
  private static int error_counter = 0;
 public static void main(String args[]) throws ParseException, FileNotFoundException {

BufferedReader  br;
 grammar parser;
   try{
     File inFile = null;
  if (0 < args.length) {
     inFile = new File(args[0]);
  } else {
     System.err.println("Invalid arguments count:" + args.length);
  }

    br = new BufferedReader(new FileReader(inFile));
    parser= new grammar(br);

     SimpleNode root = parser.Module();
     root.dump("");
  }
  catch (FileNotFoundException e) {
    System.out.println(e);
}
  System.out.println("Errors: " + error_counter);
 }
}
PARSER_END(grammar)


<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">

}
SimpleNode Module() : {Token t;}
{
  try{
    <MODULE>t=<ID> {jjtThis.setName(t.image);}<LCHAVETA> ( Declaration() )* ( Function() )* <RCHAVETA>
  }catch(ParseException e){
    String msg="Error in module";
    error_skipto(RCHAVETA,msg);
  }
  {
    return jjtThis;
  }
}

void Declaration() : {Token t1, t2; int i;}
{
  try{
    ( i=Element(){jjtThis.setElementId(i);}) ( <ASSIGN> ( ( "[" ArraySize() "]") | ( t2=<ADDSUB_OP>{jjtThis.setSignal(t2.image);} )? t1=<INTEGER>{jjtThis.setElementValue(t1.image);} ) )? <PVIRG>
  }catch(ParseException e){
    String msg="Error declaring module variables";
    error_skipto(PVIRG,msg);
  }
}

void Function() : {Token t1;}
{
  try{
    < FUNCTION >
    t1=< ID >{jjtThis.setName(t1.image);}
    (("[" "]")? < ASSIGN > < ID >)?
    < LPAR >
    (Varlist())?
    < RPAR >
  }catch(ParseException e){
      String msg="Error in function Varlist or in the return variable";
      error_skipto(RPAR,msg);
    }
     try{
      < LCHAVETA >
      Stmtlst()
      < RCHAVETA >
    }catch(ParseException ex){
        String msg="Error in function Stmtlst, there is an error in the function body";
        error_skipto(RCHAVETA,msg);
      }

}

void Varlist() : {}
{
      ( Element() )( <VIRG> ( Element()) )*
}

int Element() : {Token t;}
{
  t=<ID>{jjtThis.setName(t.image);} ("[" "]")?
  {return jjtThis.id;}
}


void Stmtlst() : {}
{
( Stmt() )*
}

void Stmt() : {}
{
  While() | If() | try{ LOOKAHEAD(3) Assign() | Call() <PVIRG>}
  catch(ParseException e){
    String msg="Error in one of the statements";
    error_skipto(PVIRG,msg);
  }
}

void Assign() : {}
{
  try{
    Lhs() <ASSIGN>
  }catch(ParseException e){

    String msg="Error found in left side of the assign!\n";
>>>>>>> b22be087f3637354bef3965819134b3228367506
    error_skipto(ASSIGN,msg);
  }
  try{
    Rhs() <PVIRG>
  }catch(ParseException e){
    String msg="Error found in right side of the assign!\n";
    error_skipto(PVIRG,msg);
  }

}

void Lhs() : {}
{
  AccessElement()
}

void Rhs() : {Token t;}
{
  ( Term() ( ( t=<ARITH_OP> | t=<BITWISE_OP> | t=<ADDSUB_OP> ){jjtThis.setOperation(t.image);} Term() )? )| "[" ArraySize() "]"
}

void ArraySize() : {Token t;}
{
(t=<ID>ScalarAccess(){jjtThis.setName(t.image);}) | (t=<INTEGER>{jjtThis.setValue(t.image);})
}

void Term() : {Token t1,t2;}
{
  ( t2=<ADDSUB_OP>{jjtThis.setSignal(t2.image);} )? ( t1=<INTEGER>{jjtThis.setElementValue(t1.image);} | LOOKAHEAD(3)Call() | AccessElement())
}

void Exprtest() : {Token t;}
{
  try{
  <LPAR> Lhs() t=<RELA_OP>{jjtThis.setOperation(t.image);} Rhs() <RPAR>
}catch(ParseException e){
  String msg="Error in Exprtest";
  error_skipto(RPAR,msg);
}
}

void While() : {}
{
  try {
    <WHILE> Exprtest() <LCHAVETA>
  }
  catch (ParseException e) {
<<<<<<< HEAD
    String msg="Error in while Exprtest";
=======
    String msg="Error in while expression!\n";
>>>>>>> b22be087f3637354bef3965819134b3228367506
    error_skipto(LCHAVETA,msg);
  }
  try {
    Stmtlst() <RCHAVETA>
  }
  catch (ParseException e) {
<<<<<<< HEAD
    String msg="Error in while body";
=======
    String msg="Error in while condition\n";
>>>>>>> b22be087f3637354bef3965819134b3228367506
    error_skipto(RCHAVETA,msg);
  }
}

void If() : {}
{
  try{
      <IF> Exprtest() <LCHAVETA>
  }catch(ParseException e){
    String msg="Error in if Exprtest";
    error_skipto(LCHAVETA,msg);
  }try{
    Stmtlst() <RCHAVETA>
  }catch(ParseException e){
    String msg="Error in if body";
    error_skipto(RCHAVETA,msg);
  }
  (try{
     <ELSE> <LCHAVETA>Stmtlst() <RCHAVETA>
  }catch(ParseException e){
    String msg="Error in else";
    error_skipto(RCHAVETA,msg);
  })?


}

void Call() : {Token t;}
{
t=<ID> {jjtThis.setName(t.image);}( "." <ID> )? <LPAR> ( ArgumentList() )? <RPAR>
}

void ArgumentList() : {}
{
Argument() ( <VIRG> Argument() )*
}

void Argument() : {Token t;}
{
( t=<ID> {jjtThis.setName(t.image);} | t=<STRING> {jjtThis.set_str_arg(t.image);}| t=<INTEGER> {jjtThis.set_int_arg(t.image);})
}

void AccessElement() : {Token t;}
  {
    t=<ID> {jjtThis.setName(t.image);}(ArrayAccess() | ScalarAccess())
  }

void ArrayAccess() : {}
{
"[" Index() "]"
}

void ScalarAccess() : {}
{
 ( "." <SIZE> )?
}

void Index() : {Token t;}
{
(  t=<ID> {jjtThis.setName(t.image);})| (t=<INTEGER>{jjtThis.setIndex(t.image);})
}

JAVACODE
void error_skipto(int kind,String error_msg) {
  ParseException e = generateParseException();  // generate the exception object.
  error_counter++;
  if(error_counter <= 10){
    System.out.println(error_msg);  // print the error message
    System.out.println(e);
  }
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}
